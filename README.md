# **My path at [42 São Paulo](https://www.42sp.org.br/)**

Projetos realizados durante meu período na [42 São Paulo](https://www.42sp.org.br/) e dicas.

42 São Paulo é uma instituição educacional inovadora que oferece treinamento gratuito em engenharia de software, utilizando uma metodologia única de aprendizado colaborativo baseada em projetos práticos. Sem professores tradicionais, o programa está disponível 24 horas por dia, 7 dias por semana, com duração de aproximadamente 18 meses, focando em linguagens de programação fundamentais e tópicos avançados. O processo de seleção inclui uma fase imersiva denominada "Piscina", e a instituição se destaca pela alta taxa de empregabilidade, com 85% dos alunos ingressando no mercado de trabalho no primeiro ano. Parte de uma rede global com 35 campi distribuídos em 22 países, a 42 São Paulo prioriza a diversidade e a inclusão, oferecendo bolsas de estudo e desenvolvendo não apenas habilidades técnicas, mas também competências essenciais, como a resolução de problemas e o trabalho em equipe.

<details>
<summary><h2><strong>Projetos</strong></h2></summary>

<details>
<summary><h3><strong>Piscina</strong></h3></summary>

A Piscine é, sem dúvida, a parte mais crucial do processo seletivo da 42, onde desenvolvemos uma variedade de projetos.

Iniciamos com shell scripting e avançamos progressivamente para tarefas utilizando a linguagem de programação C.

<p align="center">
    <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/piscina.png"/>
</p>

---

- [Shell 00](https://github.com/vinislima/42sp_piscine_shell00)
    
    O projeto "Shell 00", integrante do currículo de programação em C da 42, apresenta os alunos à criação de scripts no shell Unix. Os exercícios abordam progressivamente conceitos fundamentais, como permissões de arquivos, comandos básicos do shell e práticas de script. Entre as tarefas, estão a criação de saídas específicas de arquivos, o uso de comandos `Git`, a manipulação de sistemas de arquivos e a elaboração de scripts para automatizar operações, como a limpeza de arquivos temporários ou a identificação de arquivos ignorados em um repositório. O projeto enfatiza a atenção meticulosa aos detalhes e as avaliações entre pares, garantindo um aprendizado colaborativo e a consolidação dos fundamentos da programação em shell.
    

    ---

- [Shell 01](https://github.com/vinislima/42sp_piscine_shell01)
    
    O projeto "Shell 01" da 42 concentra-se no desenvolvimento avançado de habilidades em scripting no shell. Ele consiste em exercícios que aprimoram a proficiência em comandos Unix e lógica de script, como a listagem de grupos de usuários, a busca e a contagem de arquivos, a extração de endereços MAC e a manipulação da saída de texto. Os alunos também são desafiados com tarefas criativas, como criar arquivos com nomes específicos e realizar operações aritméticas utilizando sistemas numéricos personalizados. O projeto enfatiza a resolução cuidadosa de problemas, o rigor na aderência à sintaxe e a colaboração entre pares, reforçando assim os conceitos fundamentais do scripting no shell.
    
    ---
    
- [C 00](https://github.com/vinislima/42sp_piscine_c00)
    
    O projeto "C 00" introduz conceitos fundamentais de programação em C, voltados para iniciantes. Os exercícios se concentram na criação de funções básicas, como a impressão de caracteres, números e combinações de dígitos, seguindo normas rigorosas de codificação. As tarefas incluem a escrita de funções para exibir o alfabeto em diversas ordens, verificar o sinal de números e gerar saídas formatadas, como combinações numéricas. O projeto utiliza exclusivamente a função `write`, assegurando uma compreensão aprofundada do gerenciamento de saída em nível baixo. Seu objetivo é incutir hábitos de codificação disciplinados e o domínio da lógica de programação, além de promover o aprendizado colaborativo e a avaliação entre pares.
    
    ---
    
- [C 01](https://github.com/vinislima/42sp_piscine_c01)
    
    Este conjunto de exercícios foca nos conceitos fundamentais de manipulação de ponteiros e `arrays` em C, com o objetivo de reforçar a compreensão dos alunos sobre operações com ponteiros. Cada tarefa requer a implementação de uma função sem o uso de funções externas, com exceção da função write, utilizada no exercício de exibição de strings. As atividades abrangem desde a atribuição de valores a inteiros através de ponteiros e a troca de valores entre inteiros, até a realização de operações matemáticas (divisão e módulo) com resultados armazenados em ponteiros. Além disso, os exercícios envolvem o manuseio de strings – incluindo a exibição e a contagem de caracteres – e a inversão e ordenação de arrays de inteiros. Os alunos devem submeter seus arquivos de código conforme as especificações de cada exercício.
    
    ---
    
- [C 02](https://github.com/vinislima/42sp_piscine_c02)
    
    Este conjunto de exercícios no módulo C 02 da 42 Piscine foca na manipulação de strings e operações de memória. Envolve a implementação de versões personalizadas de funções da biblioteca padrão (como `strcpy`, `strncpy` e `strlcpy`) e de funções utilitárias para verificar características de strings (por exemplo, se as strings contêm apenas caracteres alfabéticos, numéricos, imprimíveis, maiúsculos ou minúsculos). Outras tarefas incluem transformar strings (para maiúsculas, minúsculas ou capitalizando palavras), exibir caracteres não imprimíveis em hexadecimal e imprimir regiões de memória com uma representação formatada.
    
    Os exercícios aumentam em dificuldade e têm como objetivo fortalecer a compreensão de strings, ponteiros e gerenciamento de memória em C. Os alunos devem seguir rigorosamente as normas de codificação, verificadas pela Moulinette, e submeter seu trabalho conforme as especificações para serem aprovados nos testes automatizados.
    
    ---
    
- [C 03](https://github.com/vinislima/42sp_piscine_c03)
    
    Este módulo na Piscine de C da 42 foca na manipulação avançada de strings utilizando funções que replicam comportamentos da biblioteca padrão de C. As tarefas progridem em dificuldade, abrangendo comparações, concatenação, busca por substrings e gerenciamento do tamanho das strings.
    
    Os alunos devem seguir normas rigorosas e submeter apenas os arquivos exigidos para serem aprovados no sistema de correção automatizada, Moulinette. O cumprimento dessas diretrizes garante que o código compile e funcione corretamente sob flags específicas do compilador (`-Wall -Wextra -Werror`).
    
    ---
    
- [C 04](https://github.com/vinislima/42sp_piscine_c04)
    
    O módulo C 04 foca em operações com strings e números em `C`, mesclando habilidades fundamentais — como contar caracteres e exibir strings — com tarefas intermediárias, como converter números entre diferentes bases. Os exercícios evoluem de forma progressiva, com ênfase na validação de entrada e no tratamento de erros, especialmente nas conversões de base. Essa abordagem garante uma base sólida para aplicações práticas, como o processamento de entradas do usuário e sistemas numéricos personalizados, enquanto as normas rígidas e as restrições de compilação reforçam boas práticas de codificação voltadas para o desenvolvimento no mundo real.
    
    O módulo C 04 oferece uma introdução sólida a técnicas essenciais de programação em C, combinando conceitos fundamentais e intermediários. Ao concluir esses exercícios, os alunos aprofundam sua compreensão sobre manipulação de strings e números, preparando-se para desafios mais avançados nos módulos seguintes.
    
    ---
    
- [rush 00](https://github.com/vinislima/42sp_piscine_rush00)
    
   O Rush 00 introduz os alunos à programação colaborativa em C, desafiando-os a gerar padrões de formas retangulares utilizando caracteres. O projeto integra conceitos essenciais como o uso da função `write` para saída, o controle de estruturas como laços aninhados e a validação de entrada para lidar com casos extremos. As equipes devem seguir rigorosamente as normas de codificação e respeitar as diretrizes de entrega do projeto, incentivando a disciplina na organização do código e no tratamento de erros.
    
    O Rush 00 oferece uma introdução prática ao trabalho em equipe e às habilidades fundamentais de programação em C. Ao enfrentar esse projeto, os alunos ganham experiência concreta em codificação estruturada, desenvolvem atenção aos detalhes e se preparam para desafios mais complexos ao longo da formação na 42.
    
    ---
    
- [rush 01](https://github.com/vinislima/42sp_piscine_rush01)
    
    O Rush 01 foca na resolução de quebra-cabeças lógicos com restrições, utilizando a linguagem C. O projeto combina habilidades fundamentais, como validação de entrada e tratamento de erros, com técnicas intermediárias de resolução de problemas voltadas para desafios em grade. Os alunos devem implementar um programa que preencha uma matriz 4x4 com números, baseando-se em pistas de visibilidade, garantindo valores únicos nas linhas e colunas e respeitando todas as restrições. Há uma ênfase especial na criação de algoritmos eficientes, no gerenciamento dinâmico de memória e na obediência rigorosa às normas de codificação.
    
    O Rush 01 oferece uma introdução abrangente ao raciocínio lógico e a conceitos avançados de programação em C. Ao concluir esse projeto, os alunos fortalecem suas habilidades de resolução de problemas, aprendem a lidar com entradas complexas e se preparam para enfrentar desafios mais sofisticados nos módulos futuros.
    
    ---
    
- [rush 02](https://github.com/vinislima/42sp_piscine_rush02/)
    
    O Rush 02 foca no processamento de texto e números em C, combinando tarefas fundamentais, como a leitura de entradas e a exibição de texto, com desafios intermediários, como o gerenciamento dinâmico de dicionários e a conversão de números para suas representações textuais. Os exercícios dão ênfase ao tratamento robusto de erros, ao gerenciamento de memória e ao respeito às regras de formatação do dicionário, garantindo uma base sólida para lidar com entradas complexas e dados estruturados.
    
    O Rush 02 oferece uma introdução completa a técnicas essenciais de programação em C, unindo resolução prática de problemas com padrões rigorosos de codificação. Ao concluir esse projeto, os alunos aprofundam seus conhecimentos em processamento de texto, validação de entrada e uso dinâmico de memória, preparando-se para desafios mais avançados nos módulos seguintes.
    

---

</details>

<details>
<summary><h3><strong>Warm Up</strong></h3></summary>

O **Warm Up** na 42 funciona como uma fase preparatória para revisitar os fundamentos essenciais de programação aprendidos durante a Piscine. Esses exercícios abordam tópicos como laços, funções, ponteiros e estruturas de dados, reforçando tanto a base sintática quanto a semântica da linguagem C.

Junto com as habilidades técnicas, o aquecimento introduz a avaliação entre pares, ensinando comunicação eficaz, empatia e colaboração, que são valores centrais da metodologia de aprendizado da 42. Essa fase ajuda os alunos a ganhar confiança e se preparar para os desafios do currículo da 42.

<p align="center">
    <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/phase_onee.png"/>
</p>

---

- [P2P 101](https://github.com/vinislima/42sp_common_core_p2p_101)
    
    O projeto **P2P 101: Avaliação e Comunicação** prepara os alunos da 42 para avaliações entre pares. Ele introduz o conceito de **Comunicação Não-Violenta (CNV)** para resolver conflitos e promover empatia durante as avaliações. O projeto inclui exercícios sobre a aplicação dos princípios e cenários da CNV, com o objetivo de desenvolver habilidades de comunicação e resolução de problemas. Também explica o processo de avaliação, com fluxogramas e diretrizes práticas.
    
    ---
    
- [Piscine Reloaded](https://github.com/vinislima/42sp_common_core_reloaded)
    
    O projeto **Piscine Reloaded** é uma coleção de exercícios que revisita os fundamentos da programação em C. Ele abrange tópicos como laços, ponteiros, manipulação de strings, estruturas e gerenciamento de memória. O objetivo é reforçar o aprendizado prático adquirido durante a Piscine, sem reutilizar o código anterior. O projeto inclui regras específicas de submissão e avaliação automatizada pela Moulinette, com ênfase no cumprimento das normas e práticas de codificação.
    

---

</details>

<details>
<summary><h3><strong>Common Core</strong></h3></summary>

O **Common Core** da 42 é a etapa fundamental do currículo, projetada para oferecer uma base sólida em engenharia de software. Com duração de 12 a 18 meses, essa fase prepara os alunos para os desafios técnicos da área de tecnologia por meio de aprendizado prático e projetos inspirados em situações do mundo real.

Os alunos iniciam sua jornada explorando a programação em `C` e `C++`, passando de conceitos fundamentais a tópicos avançados, como os paradigmas imperativo e orientado a objetos. Essa introdução rigorosa estabelece as bases para compreender a fundo as complexidades da codificação e do desenvolvimento de software.

O currículo também abrange algoritmos e estruturas de dados, capacitando os alunos a criar soluções eficientes e a manipular dados de forma eficaz. Esses tópicos centrais são essenciais para enfrentar problemas computacionais complexos e otimizar o desempenho de softwares.

Além disso, os alunos mergulham em arquitetura de sistemas e redes. Eles aprendem os fundamentos da administração de sistemas `UNIX`, adquirem uma compreensão sobre a arquitetura de redes e exploram a programação cliente-servidor — conhecimentos essenciais para a construção de sistemas confiáveis e escaláveis.

O programa também introduz programação gráfica e web por meio de projetos como o `Fract-ol`, focado na criação de fractais, e o `ft_transcendence`, que envolve o desenvolvimento de plataformas web interativas. Esses projetos permitem que os alunos experimentem aspectos criativos e técnicos do design de software.

---

<details>
<summary><h3><strong>Milestone 0</strong></h3></summary>

- [Libft](https://github.com/vinislima/42sp_common_core_libft)
    
    A primeira **milestone** na 42 é representado pelo projeto `Libft`, um dos primeiros grandes desafios que os alunos enfrentam após concluir o **warmup**. O objetivo principal do projeto é criar uma biblioteca estática personalizada em C, reimplementando diversas funções da biblioteca padrão (`libc`). Os alunos devem escrever suas próprias versões dessas funções e utilizar um `Makefile` para compilar o código corretamente. Essa biblioteca será reutilizada em projetos futuros, já que o uso direto das funções da biblioteca padrão em C é proibido na maioria dos projetos da 42. Com essa milestone, os alunos não apenas reforçam sua compreensão sobre os conceitos fundamentais de programação, como também aprendem a estruturar e organizar o código de acordo com diretrizes rigorosas — algo essencial para o sucesso em projetos mais avançados. Além disso, esse projeto introduz os sistemas de testes e correções automatizadas utilizados pela 42, como a Moulinette, que avalia o código com base em critérios específicos.
    
    <p align="center">
        <a href = "https://github.com/vinislima/42sp_common_core_libft">
            <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/libfte.png" />
        </a>
    </p>
    

---

</details>

<details>
<summary><h3><strong>Milestone 1</strong></h3></summary>

- [ft_printf](https://github.com/vinislima/42sp_common_core_ft_printf)
    
   O projeto **ft_printf** tem como foco recriar a funcionalidade da função `printf()` da biblioteca padrão em C. Ele desafia os participantes a implementar uma versão personalizada capaz de lidar com diversos especificadores de formato, como `%c`, `%s`, `%p`, `%d`, `%i`, `%u`, `%x`, `%X` e `%%`. O objetivo é desenvolver uma implementação estruturada e eficiente, respeitando padrões rigorosos de codificação, garantindo segurança de memória e evitando comportamentos indefinidos. Esse exercício também introduz o uso de funções variádicas, permitindo o tratamento de um número variável de argumentos, além de oferecer uma excelente oportunidade para aprofundar as habilidades de programação em C.
    
    Além dos requisitos obrigatórios, o projeto inclui bônus opcionais, como o suporte a flags (`-0.# +`) e especificações de largura de campo. No entanto, esses bônus só são avaliados caso a implementação principal atenda perfeitamente a todos os critérios exigidos. Ao concluir o projeto, a versão personalizada do `ft_printf()` pode ser integrada à biblioteca pessoal do participante (`libft`), tornando-se uma ferramenta valiosa para projetos futuros em C.

  <p align="center">
    <a href = "https://github.com/vinislima/42sp_common_core_ft_printf">
        <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/ft_printfn.png" />
    </a>
  </p>
  
    ---
    
- [get_next_line](https://github.com/vinislima/42sp_common_core_get_next_line)
    
    O projeto **get_next_line** desafia os participantes a implementar uma função capaz de ler uma linha por vez a partir de um `file descriptor`. Essa função imita o comportamento de ferramentas como `getline()`, mas deve respeitar restrições rigorosas, como o gerenciamento dinâmico de memória e a busca por eficiência. O projeto introduz conceitos como o uso de variáveis estáticas para manter o estado entre chamadas da função e leitura com buffer, garantindo um desempenho otimizado tanto para arquivos pequenos quanto para arquivos grandes.

    Principais características do `get_next_line` incluem:

    - Leitura incremental de arquivos utilizando um buffer de tamanho pré-definido (`BUFFER_SIZE`).
    - Retorno de linhas completas, incluindo o caractere de nova linha (`\n`), quando presente.
    - Suporte tanto para a entrada padrão (`stdin`) quanto para descritores de arquivos.
    - Gerenciamento seguro de memória para evitar vazamentos ou comportamentos indefinidos.

    Este projeto enfatiza a modularidade, com a lógica principal distribuída entre funções auxiliares para manipulação de strings e gerenciamento de memória. Ele testa a compreensão do participante sobre ponteiros, alocação dinâmica e tratamento de erros em C.

  <p align="center">
    <a href = "https://github.com/vinislima/42sp_common_core_get_next_line">
        <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/get_next_linee.png" />
    </a>
  </p>
  
    ---
    
- [Born2beroot](https://github.com/vinislima/42sp_common_core_born_2_be_root)

    O projeto **Born2beRoot** introduz os participantes à administração de sistemas e aos fundamentos da virtualização. O objetivo é configurar uma máquina virtual como um servidor seguro, seguindo diretrizes rigorosas. Os participantes escolhem entre `Debian` ou `Rocky Linux` para criar um ambiente minimalista e eficiente, sem interfaces gráficas.

    O projeto enfatiza conceitos-chave de administração de sistemas, incluindo acesso seguro, gerenciamento de usuários, armazenamento criptografado e configuração de serviços. Além disso, um script de monitoramento personalizado é desenvolvido para automatizar o relatório de status do sistema.

    Esse desafio serve como uma introdução ao gerenciamento e à segurança de servidores, proporcionando uma base sólida para projetos futuros na administração de sistemas.

  <p align="center">
    <a href = "https://github.com/vinislima/42sp_common_core_born_2_be_root">
        <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/born2beroote.png" />
    </a>
  </p>

---

</details>

<details>
<summary><h3><strong>Milestone 2</strong></h3></summary>

A segunda milestone na 42 é representada por um conjunto de sete projetos que desafiam os alunos a aplicar conceitos avançados de C e Unix em cenários distintos.

O **Exam Rank 02** testa habilidades em C através de níveis progressivos. O level_01 foca na manipulação básica de strings, como encontrar palavras, inverter strings e recriar funções como `ft_strlen`.
O level_02 avança para manipulações mais complexas, como conversões de `camelCase` para `snake_case`, recriação de `ft_atoi` e `ft_strdup`, e introduz operações a nível de bits.
Níveis superiores, como level_03 e level_04, aumentam a complexidade, exigindo conhecimento de algoritmos, estruturas de dados e gerenciamento de memória.

Já no **pipex**, implementam a criação de pipelines e o redirecionamento de entrada e saída, simulando comportamentos de um `shell`;<br>

Com **minitalk**, exploram comunicação entre processos via sinais, lidando com sincronização e segurança na troca de mensagens binárias;<br>

O **push_swap** exige a ordenação de números usando apenas duas pilhas e comandos restritos, aprimorando o raciocínio algorítmico e a otimização de operações;<br>

No **so_long**, implementam um jogo simples em 2D, tratando mapas, eventos de teclado e fluxo de renderização com bibliotecas gráficas mínimas;<br>

O **FdF** leva a visualização a três dimensões em `wireframe`, introduzindo transformações de coordenadas e projeções isométricas;<br>
Por fim, no **Fract‑ol**, investigam a geração e renderização interativa de fractais, aplicando conceitos matemáticos e, opcionalmente, paralelismo para manter bom desempenho.<br>

Com essa milestone, os alunos não apenas consolidam seu entendimento de gerenciamento de memória, processos e gráficos em C, mas também se familiarizam com diretrizes rigorosas de organização de código e com o sistema de testes automatizados, essencial para projetos mais complexos no currículo da 42.

---

- [minitalk](https://github.com/vinislima/42sp_common_core_minitalk)
    
    <p align="center">
        <a href = "https://github.com/vinislima/42sp_common_core_minitalk">
            <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/minitalkm.png" />
        </a>
    </p>
    
    O projeto **minitalk** tem como foco recriar um sistema mínimo de comunicação entre processos em C, usando apenas sinais UNIX (`SIGUSR1` e `SIGUSR2`). Ele desafia os participantes a desenvolver dois programas — um **server** e um **client** — capazes de transmitir texto bit a bit sem recorrer a pipes, sockets ou memória compartilhada. O servidor deve exibir seu PID ao iniciar e ficar aguardando sinais; o cliente recebe o PID do servidor e uma string, converte cada caractere em sequência de bits e envia sinais, sincronizando via `pause()` até receber confirmação antes de prosseguir.
    
    Nos requisitos obrigatórios, é preciso instalar handlers com `signal()` ou `sigaction()`, codificar “0” e “1” em sinais distintos, garantir que o servidor reconstrua e exiba corretamente a mensagem (incluindo caracteres especiais e `\n`), e tratar erros como PID inválido ou falha no envio de sinal.
    
    Como bônus, o projeto pode incluir suporte a múltiplos clientes simultâneos, mantendo estados de comunicação separados por PID, além de implementar temporizadores para evitar deadlocks, tratamento de sinais interrompidos e otimizações para mensagens longas sem perda de dados.
    
    Ao concluir, os executáveis `server` e `client` podem ser integrados à sua biblioteca pessoal (`libft`), oferecendo uma ferramenta prática para futuros exercícios de comunicação de processos em C.
    
    ---
    
- [Exam Rank 02](https://github.com/vinislima/42sp_common_core_exams/tree/main)
    
    <p align="center">
        <a href = "https://github.com/vinislima/42sp_common_core_exams/tree/main">
            <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/exam_rank_02.png" width="150" height="150"/>
        </a>
    </p>
    
    **[Level 01: Fundamentos de C](https://github.com/vinislima/42sp_common_core_exams/tree/main/exam_rank_02/level_01)**

    O primeiro nível é dedicado a consolidar os conceitos básicos de C, como tipos primitivos, operadores aritméticos e controle de fluxo (if/else, loops). Os participantes desenvolvem funções simples — por          exemplo, ft_abs.c, que calcula o valor absoluto de um inteiro usando operadores condicionais; e is_alpha.c, que verifica se um caractere pertence ao alfabeto por meio de comparações diretas. Nessa fase, é        essencial aprender a tratar entradas válidas e inválidas, preparar protótipos claros e garantir que o código compile sem warnings.

    **[Level 02: Lógica Intermediária e Arrays](https://github.com/vinislima/42sp_common_core_exams/tree/main/exam_rank_02/level_02)**

    Neste estágio, o foco se volta à manipulação de arrays e aplicação de estruturas de repetição. Os alunos criam funções que iteram sobre coleções de dados, validam inputs e tratam bordas como arrays nulos ou     vazios. Em max.c, por exemplo, a tarefa é identificar o maior elemento de um array, retornando um valor padrão quando o ponteiro for nulo ou o tamanho for zero. Já em safe_sum.c, desenvolve-se uma soma segura     de inteiros, com checagens antecipadas para evitar comportamento indefinido.

    **[Level 3: Recursão e Estruturas Dinâmicas](https://github.com/vinislima/42sp_common_core_exams/tree/main/exam_rank_02/level_03)**

    O terceiro nível apresenta recursão e estruturas alocadas em heap, enfatizando abstração e gerenciamento de memória. Em ft_list_size.c, os alunos implementam a contagem de nós de uma lista encadeada de forma     recursiva, aprendendo a dividir problemas em subproblemas. Com add_node.c, praticam a criação e inserção de nós no início da lista, consolidando o uso de malloc e ponteiros. Além disso, lcm.c desafia a           aplicação de propriedades matemáticas para otimizar o cálculo do mínimo múltiplo comum entre dois números.

    **[Level 4: Manipulação de Strings e Ordenação em Listas](https://github.com/vinislima/42sp_common_core_exams/tree/main/exam_rank_02/level_04)**

    No nível final, os exercícios integram técnicas de gestão de buffers, tokenização e algoritmos de ordenação em contextos textuais e dinâmicos. Por exemplo, em rosting.c, reordenam-se palavras de uma frase        movendo a primeira para o fim, exigindo realocação de buffer e cuidado com índices para evitar vazamentos. Em ft_split_pocket.c, implementa-se a divisão de uma string em substrings, retornando um array de        palavras alocado dinamicamente. Por fim, ft_list_sort.c convida a ordenar uma lista encadeada usando algoritmos como Bubble Sort ou Merge Sort adaptados, lidando com troca de ponteiros e assegurando              eficiência.

    ---
  
- [push_swap](https://github.com/vinislima/42sp_common_core_push_swap)
    
    <p align="center">
        <a href = "https://github.com/vinislima/42sp_common_core_push_swap">
            <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/push_swape.png" />
        </a>
    </p>

    O projeto **Push_swap** tem como foco a ordenação de dados em uma pilha utilizando um conjunto limitado de instruções, com o desafio de alcançar o menor número possível de operações. Ele testa a habilidade dos participantes em desenvolver        algoritmos eficientes em C para escolher a estratégia de ordenação mais otimizada.

    Ele desafia os participantes a desenvolver um programa principal — o `push_swap` — capaz de receber uma lista de inteiros, que representa a pilha inicial 'a', e gerar a sequência mais curta de instruções específicas para ordenar esses            inteiros. Opcionalmente, um segundo programa, o checker, pode ser desenvolvido para verificar a correção da sequência de instruções.

    O mecanismo de funcionamento envolve duas pilhas, 'a' (inicialmente com os números a serem ordenados) e 'b' (inicialmente vazia). O push_swap deve calcular e exibir a sequência de operações (como `sa`, `pb`, `ra`, etc.) que ordenam a pilha       'a' com o menor número no topo e a pilha 'b' vazia. O checker, se implementado, recebe uma pilha inicial e uma lista de instruções, executando-as e indicando se a pilha foi ordenada corretamente ("OK") ou não ("KO").

    Nos requisitos obrigatórios, é preciso desenvolver o push_swap em C, seguindo a Norma da 42 (sem variáveis globais, gestão de memória impecável). Deve haver um Makefile com as flags `-Wall`, `-Wextra`, `-Werror` e regras padrão. O programa       deve aceitar inteiros como argumentos (primeiro argumento é o topo da pilha), tratar erros (argumentos inválidos, duplicatas, exibindo "Error" na stderr) e imprimir a sequência de instruções na stdout (uma por linha). O desempenho é crucial,     com benchmarks específicos para 100 e 500 números (ex: <700 operações para 100 números na validação máxima).

    Como bônus, o projeto pode incluir o desenvolvimento do programa checker. Este programa lê a pilha inicial como argumentos e as instruções da entrada padrão, validando se as instruções ordenam a pilha. Ele também deve tratar erros de entrada     e instruções inválidas. A avaliação do bônus depende da perfeição da parte obrigatória, incluindo o cumprimento dos benchmarks mais exigentes.

    Ao concluir, o push_swap (e o checker opcional) serve como um exercício fundamental sobre algoritmos de ordenação, sua complexidade e otimização, consolidando habilidades de resolução de problemas e programação em C, frequentemente avaliadas     em contextos profissionais.

   ---
  
- [fract-ol](https://github.com/vinislima/42sp_common_core_fract_ol)
    
    <p align="center">
        <a href = "https://github.com/vinislima/42sp_common_core_fract_ol">
            <img src="https://raw.githubusercontent.com/vinislima/badges_42/refs/heads/main/badges/fract-ole.png" />
        </a>
    </p>

    O projeto **Fract'ol** foca na criação de um programa de exploração de fractais em C, permitindo aos usuários gerar e visualizar fractais matematicamente belos. Ele desafia os participantes a renderizar padrões geométricos complexos e            gerenciar interações gráficas usando uma biblioteca gráfica específica.

    O projeto exige que os participantes desenvolvam um programa — fractol — capaz de exibir diferentes tipos de fractais, como o conjunto de **Mandelbrot** e o conjunto de **Julia**. O programa deve receber parâmetros pela linha de comando para     determinar qual fractal exibir e para personalizar sua aparência, particularmente para diferentes conjuntos de Julia. Os usuários interagirão com o fractal dando zoom para aproximar e afastar usando a roda do mouse.

    O mecanismo central envolve o uso da biblioteca MiniLibX para abrir uma janela, criar imagens e lidar com eventos de teclado e mouse. O programa deve calcular e renderizar o fractal escolhido pixel por pixel, aplicando cores para representar     a "profundidade" ou iterações de escape de cada ponto, com incentivo à experimentação com esquemas de cores psicodélicas.

    Os principais requisitos obrigatórios incluem:

     - Implementar mais um tipo diferente de fractal.
     - Fazer o zoom seguir a posição atual do cursor do mouse.
     - Permitir a movimentação da visualização usando as teclas de seta.
     - Implementar uma mudança na gama de cores. A parte bônus só será avaliada se a parte obrigatória estiver perfeita.

    Ao concluir, o executável fractol oferece uma maneira envolvente de explorar a beleza dos fractais matemáticos, ao mesmo tempo em que proporciona aos estudantes experiência prática com programação gráfica, manipulação de eventos e otimização     usando a biblioteca MiniLibX.

---

</details>
<details>
<summary><h3><strong>Milestone 3</strong></h3></summary>

A terceira milestone na 42 consolida e expande o conhecimento em programação **C** e conceitos de sistemas `Unix`, focando na implementação de funcionalidades complexas e no gerenciamento de concorrência.

Primeiramente, os alunos enfrentam o **Exam 03**, onde devem recriar com perfeição uma de duas funções clássicas: `get_next_line`, que lê uma linha de um descritor de arquivo, ou `ft_printf`, uma réplica da função `printf` da biblioteca C padrão. Este exame testa a atenção a detalhes, o manejo rigoroso de memória e a compreensão profunda do comportamento de funções de baixo nível.

Em seguida, o projeto **Minishell** desafia os alunos a construir um interpretador de comandos interativo, similar ao `bash`. Este projeto abrange a análise e execução de comandos, o gerenciamento de processos (criação, sinais), redirecionamentos de entrada/saída, `pipes`, e a manipulação de variáveis de ambiente. É um mergulho profundo no funcionamento interno de um `shell Unix` e na interação com o sistema operacional.

Por fim, com **Philosophers**, os alunos exploram problemas clássicos de concorrência e sincronização. O objetivo é simular o "jantar dos filósofos", onde múltiplos "filósofos" (threads ou processos) precisam compartilhar recursos (garfos) para comer, evitando deadlocks e starvation. Este projeto exige o uso cuidadoso de `mutexes` e semáforos (ou outras primitivas de sincronização) e desenvolve o raciocínio sobre sistemas concorrentes.

Com essa milestone, os alunos aprofundam seu conhecimento em C, demonstram a capacidade de implementar utilitários de sistema complexos e aprendem a gerenciar recursos compartilhados em ambientes concorrentes, habilidades cruciais para o desenvolvimento de software robusto e eficiente.

---

</details>

</details>

</details>
